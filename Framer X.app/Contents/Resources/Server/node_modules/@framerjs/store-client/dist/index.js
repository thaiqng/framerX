'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var request = _interopDefault(require('request-promise-native'));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/**
 * Recursively merges the given records.
 */
// Visible for testing
var mergeRequestInit = function (left, right) {
    if (!right) {
        return left;
    }
    return __assign({}, left, right, { headers: __assign({}, left.headers, right.headers) });
};
/**
 * A network error handler
 *
 * From the MDN docs:
 * > A fetch() promise will reject with a TypeError when a network error is encountered or CORS is misconfigured on
 * > the server side, although this usually means permission issues or similar â€” a 404 does not constitute
 * > a network error, for example.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
 */
var withDefaultNetworkErrorHandler = function (request$$1) { return function (error) {
    if (error.name === "TypeError") {
        throw new NetworkError(error.message || "", request$$1);
    }
    throw error;
}; };
var withResponseLogger = function (debug) { return function (res) {
    if (debug) {
        console.log("HTTP Response", res);
    }
    return res;
}; };
// Visible For Testing
var composeQueryString = function (queryParams) {
    if (queryParams === void 0) { queryParams = {}; }
    if (Object.keys(queryParams).length === 0) {
        return "";
    }
    return ("?" +
        Object.keys(queryParams)
            .map(function (key) {
            var val = "" + queryParams[key];
            return encodeURIComponent(key) + "=" + encodeURIComponent(val);
        })
            .join("&"));
};
// Visible For Testing
var composeErrorHandler = function (req, throwByDefaultIf, throwIf) {
    return function (res) {
        var shouldThrow = throwIf || throwByDefaultIf;
        if (shouldThrow({ req: req, res: res })) {
            throw new ApiError(req, res);
        }
        return res;
    };
};
// Visible For Testing
var composeRequestParser = function (req, defaultResponseParser, responseParser) {
    return function (res) {
        var parser = responseParser || defaultResponseParser;
        return parser({ req: req, res: res });
    };
};
// ---- Public API ----
/**
 * Joins two or more paths with a "/", useful for avoiding "/foo//bar/" kind of errors when you don't know if the input will already contain a slash.
 */
var joinPaths = function (left, right) {
    var paths = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        paths[_i - 2] = arguments[_i];
    }
    var joiner = function (left, right) {
        if (!left || !right || left.length === 0 || right.length === 0) {
            throw new Error("Neither left (" + left + ") nor right (" + right + ") can have a length of zero.");
        }
        var adjustedLeft = left.endsWith("/")
            ? left.substring(0, left.length - 1)
            : left;
        var adjustedRight = right.startsWith("/")
            ? right.substring(1)
            : right;
        return [adjustedLeft, adjustedRight].join("/");
    };
    return paths.reduce(joiner, joiner(left, right));
};
var ApiError = /** @class */ (function (_super) {
    __extends(ApiError, _super);
    function ApiError(request$$1, response) {
        var _this = _super.call(this, "Got " + response.status + " when calling " + response.url + " ") || this;
        _this.request = request$$1;
        _this.name = "ApiError";
        _this.status = response.status;
        return _this;
    }
    return ApiError;
}(Error));
var NetworkError = /** @class */ (function (_super) {
    __extends(NetworkError, _super);
    function NetworkError(message, request$$1) {
        var _this = _super.call(this, "Failed to fetch " + (request$$1.init.method || "GET") + " " + request$$1.url + ". " + message) || this;
        _this.name = "NetworkError";
        _this.request = request$$1;
        return _this;
    }
    return NetworkError;
}(Error));
var isApiError = function (object) {
    return object.name === "ApiError";
};
var isNetworkError = function (object) {
    return object.name === "NetworkError";
};
/**
 * Creates a new HttpClient.
 *
 * @param opts a configuration options object.
 */
var createClient = function (opts) {
    var fetchImpl = opts.fetch;
    return function (req) {
        var url = joinPaths(req.rootUrl || opts.rootUrl, req.path) +
            composeQueryString(req.queryParams);
        var init = mergeRequestInit(opts.defaultRequestInit, req.init);
        var request$$1 = { url: url, init: init };
        var errorHandler = composeErrorHandler(request$$1, opts.throwByDefaultIf, req.throwIf);
        var requestParser = composeRequestParser(request$$1, opts.defaultResponseParser, req.parser);
        if (opts.debug) {
            console.log("HTTP Request:", request$$1);
        }
        return fetchImpl(url, init)
            .catch(withDefaultNetworkErrorHandler(request$$1))
            .then(errorHandler)
            .then(requestParser)
            .then(withResponseLogger(opts.debug));
    };
};

var http = /*#__PURE__*/Object.freeze({
    mergeRequestInit: mergeRequestInit,
    withDefaultNetworkErrorHandler: withDefaultNetworkErrorHandler,
    withResponseLogger: withResponseLogger,
    composeQueryString: composeQueryString,
    composeErrorHandler: composeErrorHandler,
    composeRequestParser: composeRequestParser,
    joinPaths: joinPaths,
    ApiError: ApiError,
    NetworkError: NetworkError,
    isApiError: isApiError,
    isNetworkError: isNetworkError,
    createClient: createClient
});

/**
 * A subset of `map` which only contains keys that passed the predicate
 */
var filterKeys = function (map, predicate) {
    var resultingMap = {};
    for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {
        var key = _a[_i];
        var val = map[key];
        if (predicate(key, val)) {
            resultingMap[key] = map[key];
        }
    }
    return resultingMap;
};
/**
 * Derives a new object from `map` where the values are transformed by applying the `mapper` function.
 */
var mapValues = function (map, mapper) {
    var resultingMap = {};
    for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {
        var key = _a[_i];
        var val = map[key];
        resultingMap[key] = mapper(val);
    }
    return resultingMap;
};
/**
 * Splits the given map into two sub-maps by the given predicate.
 * The left map will contain keys that matched the predicate, the right map will contain keys that didn't.
 */
var splitMap = function (map, predicate) {
    return [
        filterKeys(map, function (key) { return predicate(key); }),
        filterKeys(map, function (key) { return !predicate(key); })
    ];
};

var _this = undefined;
var createRootUrl = function (isPrivateStore, rootUrl) {
    return isPrivateStore
        ? joinPaths(rootUrl, "/store/packages/private/")
        : joinPaths(rootUrl, "/store/packages/");
};
var createStoreClient = function (_a) {
    var rootUrl = _a.rootUrl, privateStore = _a.privateStore, fetch = _a.fetch, token = _a.token, debug = _a.debug;
    var headers = token
        ? {
            "content-type": "application/json; charset=utf-8",
            Authorization: "Token " + token
        }
        : { "content-type": "application/json; charset=utf-8" };
    return createClient({
        rootUrl: createRootUrl(privateStore, rootUrl),
        defaultRequestInit: {
            headers: headers
        },
        defaultResponseParser: function (_a) {
            var res = _a.res;
            return res.json();
        },
        throwByDefaultIf: function (_a) {
            var res = _a.res;
            return !res.ok;
        },
        fetch: fetch,
        debug: debug
    });
};
var toPackages = function (_a) {
    var data = _a.data, meta = _a.meta;
    return ({
        packages: data.map(toPackage),
        totalCount: Number(meta["x-total-count"]) || 0
    });
};
/**
 * Maps a package returned from the API to a "local" Package.
 */
var toPackage = function (pack) {
    var priv = pack["private"], tags = pack.tags, rest = __rest(pack, ["private", "tags"]);
    return __assign({}, rest, { tags: tags || [], isPrivate: !!priv });
};
/**
 * Maps a package returned from the API to a "local" Package.
 */
var toPackageMeta = function (pack) {
    var priv = pack["private"], rest = __rest(pack, ["private"]);
    return __assign({}, rest, { isPrivate: !!priv });
};
var PACKAGES_PER_PAGE = 36;
var packagesParser = function (reqRes) { return __awaiter(_this, void 0, void 0, function () {
    var totalCount, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                totalCount = reqRes.res.headers["x-total-count"];
                return [4 /*yield*/, reqRes.res.json()];
            case 1:
                data = _a.sent();
                return [2 /*return*/, {
                        data: data,
                        meta: {
                            "x-total-count": totalCount
                        }
                    }];
        }
    });
}); };
/**
 * An HTTP based Store Client
 */
var HttpStoreClient = /** @class */ (function () {
    function HttpStoreClient(opts) {
        this.request = createStoreClient(__assign({}, opts, { fetch: opts.fetch }));
        this.privateStore = opts.privateStore;
        this.rootUrl = opts.rootUrl;
    }
    /**
     * Finds the package with the given name.
     *
     * @param packageName a package's `name`
     */
    HttpStoreClient.prototype.findByName = function (_a) {
        var packageName = _a.packageName;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                return [2 /*return*/, this.request({
                        path: "/" + packageName
                    }).then(toPackage)];
            });
        });
    };
    /**
     * @returns true if there is a package with the given name.
     */
    HttpStoreClient.prototype.containsPackage = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // we skip the default error checking and parsing because we only want to check the response's status code.
                return [2 /*return*/, this.request({
                        path: "/find-by-slugify",
                        queryParams: { name: opts.friendlyName },
                        throwIf: function (_a) {
                            var res = _a.res;
                            return res.status !== 404 && !res.ok;
                        },
                        parser: function (_a) {
                            var res = _a.res;
                            return res;
                        }
                    }).then(function (response) {
                        return { contained: response.ok };
                    })];
            });
        });
    };
    /**
     * Toggles a packages "favorite" status.
     *
     * NOTE: Unfortunately if a package is already a favorite and you try to favorite, it will result in an error.
     * We circunvent this behaviour by always calling `findByName` , disregarding the result of the toggle
     * favorite endpoint.
     *
     * @param packageName a package `name`
     * @param favorite if true will set the package as favorite, if false will unfavourite the package.
     */
    HttpStoreClient.prototype.toggleFavorite = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            var promise;
            var _this = this;
            return __generator(this, function (_a) {
                promise = this.request({
                    path: "/" + opts.packageName + "/favorite",
                    init: {
                        method: opts.favorite ? "POST" : "DELETE"
                    }
                });
                return [2 /*return*/, promise
                        .then(function (_) { return _this.findByName(opts); })
                        .catch(function (_) { return _this.findByName(opts); })];
            });
        });
    };
    HttpStoreClient.prototype.find = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request({
                        path: "/",
                        parser: packagesParser
                    }).then(toPackages)];
            });
        });
    };
    HttpStoreClient.prototype.fetchRecents = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request({
                        path: "/",
                        parser: packagesParser,
                        queryParams: {
                            offset: opts.offset,
                            limit: PACKAGES_PER_PAGE
                        }
                    }).then(toPackages)];
            });
        });
    };
    HttpStoreClient.prototype.fetchPackagesBySection = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request({
                        path: "/" + opts.section,
                        parser: packagesParser,
                        queryParams: {
                            offset: opts.offset,
                            limit: PACKAGES_PER_PAGE
                        }
                    }).then(toPackages)];
            });
        });
    };
    HttpStoreClient.prototype.fetchPackagesByPublisher = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request({
                        // XXX this endpoint doesn't exist in the "private" variant. The back-end should probably normalice this at some point.
                        rootUrl: this.rootUrl + "/store/packages/",
                        path: "/published-by/" + opts.publisherId,
                        parser: packagesParser,
                        queryParams: {
                            offset: opts.offset,
                            limit: PACKAGES_PER_PAGE
                        }
                    }).then(toPackages)];
            });
        });
    };
    HttpStoreClient.prototype.fetchPackagesByPopularity = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request({
                        path: "/popular",
                        parser: packagesParser,
                        queryParams: {
                            offset: opts.offset,
                            limit: PACKAGES_PER_PAGE,
                            days: opts.days
                        }
                    }).then(toPackages)];
            });
        });
    };
    HttpStoreClient.prototype.fetchFeaturedPackages = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.privateStore
                        ? this.request({
                            path: "/",
                            parser: packagesParser,
                            queryParams: {
                                featured: "true",
                                offset: opts.offset,
                                limit: PACKAGES_PER_PAGE
                            }
                        }).then(toPackages)
                        : this.request({
                            parser: packagesParser,
                            path: "/trending"
                        }).then(toPackages)];
            });
        });
    };
    HttpStoreClient.prototype.search = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (opts.query === "") {
                    return [2 /*return*/, this.find()];
                }
                return [2 /*return*/, this.request({
                        path: "/search",
                        parser: packagesParser,
                        queryParams: {
                            query: opts.query,
                            offset: opts.offset,
                            limit: PACKAGES_PER_PAGE
                        }
                    }).then(toPackages)];
            });
        });
    };
    HttpStoreClient.prototype.getPublishStatus = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request({
                        rootUrl: createRootUrl(opts.isPrivate, this.rootUrl),
                        path: "/" + opts.packageName + "/version/" + opts.version
                    }).then(function (responseBody) {
                        var pendingStatuses = ["pending", "queued", "in_progress"];
                        return pendingStatuses.includes(responseBody.status)
                            ? // since queued and in_progress are just internal representations of work that hasn't been completed,
                             __assign({}, responseBody, { status: "pending" }) : responseBody;
                    })];
            });
        });
    };
    HttpStoreClient.prototype.fetchPreflight = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request({
                        path: "/preflight",
                        init: {
                            body: JSON.stringify(body),
                            method: "POST"
                        },
                        throwIf: function (_a) {
                            var res = _a.res;
                            return !res.ok && !(res.status >= 400 && res.status <= 499);
                        },
                        parser: function (_a) {
                            var res = _a.res;
                            return __awaiter(_this, void 0, void 0, function () {
                                var body;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0: return [4 /*yield*/, res.json()];
                                        case 1:
                                            body = _b.sent();
                                            if (res.ok) {
                                                return [2 /*return*/, __assign({ ok: true }, body)];
                                            }
                                            return [2 /*return*/, {
                                                    ok: false,
                                                    errorMessage: (body.error && body.error.message) || ""
                                                }];
                                    }
                                });
                            });
                        }
                    })];
            });
        });
    };
    HttpStoreClient.prototype.removePackage = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request({
                        path: "" + opts.packageName,
                        init: {
                            method: "DELETE"
                        },
                        parser: function (_a) {
                            var res = _a.res;
                            return res;
                        }
                    })];
            });
        });
    };
    HttpStoreClient.prototype.fetchManyPackageMeta = function (packageNames) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (packageNames.length === 0) {
                    // Don't hit the API if there is nothing to fetch.
                    return [2 /*return*/, {}];
                }
                return [2 /*return*/, this.request({
                        // The meta endpoint is the only endpoint that is not prefixed by /packages/ or /packages/private/
                        rootUrl: this.rootUrl,
                        path: "store/meta/get-many",
                        init: {
                            method: "POST",
                            body: JSON.stringify({ packageNames: packageNames })
                        }
                    })
                        .then(function (res) { return filterKeys(res, function (_, val) { return !!val; }); })
                        .then(function (res) { return mapValues(res, toPackageMeta); })];
            });
        });
    };
    HttpStoreClient.prototype.fetchMeta = function (_a) {
        var name = _a.name, _b = _a.dependencies, dependencies = _b === void 0 ? [] : _b;
        return __awaiter(this, void 0, void 0, function () {
            var packageNames, metas, _c, withName, withoutName;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        packageNames = name ? [name].concat(dependencies) : dependencies;
                        return [4 /*yield*/, this.fetchManyPackageMeta(packageNames)];
                    case 1:
                        metas = _d.sent();
                        _c = splitMap(metas, function (key) { return key === name; }), withName = _c[0], withoutName = _c[1];
                        return [2 /*return*/, {
                                meta: name === undefined ? undefined : withName[name],
                                dependenciesMeta: withoutName
                            }];
                }
            });
        });
    };
    return HttpStoreClient;
}());

var toFetchResponse = function (url, result) {
    return {
        ok: result.statusCode >= 200 && result.statusCode < 300,
        status: result.statusCode,
        url: url,
        headers: result.headers,
        text: function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, result.body.toString()];
                });
            });
        },
        json: function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, JSON.parse(result.body.toString())];
                });
            });
        }
    };
};
/**
 * A FetchFunction implementation backed by `request-promise-native`.
 */
var requestFetch = function (url, requestInit) {
    var defaultOpts = {
        resolveWithFullResponse: true
    };
    var opts = !!requestInit
        ? __assign({}, defaultOpts, { headers: requestInit.headers, body: requestInit.body, method: requestInit.method }) : __assign({}, defaultOpts, { method: "GET" });
    return request(url, opts).then(function (res) { return toFetchResponse(url, res); });
};

exports.http = http;
exports.HttpStoreClient = HttpStoreClient;
exports.requestFetch = requestFetch;
//# sourceMappingURL=index.js.map
