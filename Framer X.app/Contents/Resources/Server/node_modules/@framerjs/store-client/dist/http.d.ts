/**
 * Recursively merges the given records.
 */
export declare const mergeRequestInit: (left: FetchRequestInit, right?: FetchRequestInit | undefined) => FetchRequestInit;
/**
 * A subset of fetch's Response. Explicity restricted to facility IPC implementation.
 */
export declare type FetchResponse = {
    ok: boolean;
    status: number;
    url: string;
    headers: Record<string, string>;
    json(): Promise<any>;
    text(): Promise<string>;
};
/**
 * A subset of RequestInit. Explicity restricted to facility IPC implementation.
 */
export declare type FetchRequestInit = {
    body?: string;
    method?: string;
    credentials?: "include";
    headers?: Record<string, string>;
};
/**
 * A subset of window.fetch's type. Explicitly restricted to facilitate IPC implementation.
 */
export declare type FetchFunction = (url: string, requestInit?: FetchRequestInit) => Promise<FetchResponse>;
export declare type QueryParams = {
    [key: string]: string | number;
};
declare type FetchRequest = {
    url: string;
    init: FetchRequestInit;
};
declare type RequestResponse = {
    req: FetchRequest;
    res: FetchResponse;
};
declare type ClientOptions = {
    /**
     * The base URL of all other requests.
     */
    rootUrl: string;
    /**
     * The default `fetch` RequestInit options that will be passed onto every request.
     * This can be overriden on a per request basis.
     */
    defaultRequestInit: FetchRequestInit;
    /**
     * The error handler tells the client what it should consider as an error.
     * The error handler should throw if there was an error, otherwise just continue onto parsing.
     *
     * This can be overriden on a per request basis.
     */
    throwByDefaultIf: ResponseRejector;
    /**
     * The default request parser. This can be overriden on a per request basis.
     */
    defaultResponseParser: ResponseParser;
    /**
     * Supply your own fetch implementation, meant mostly for testing purposes.
     */
    fetch: FetchFunction;
    /**
     * If true will log all requests and responses
     */
    debug?: boolean;
};
export declare type HttpClient = (request: {
    rootUrl?: string;
    /**
     * The request's path e.g. "/users"
     */
    path: string;
    /**
     * Optionally pass a fetch RequestInit object. This will be merged with the `defaultRequestInit`
     */
    init?: FetchRequestInit;
    /**
     * Optionally pass an object representing the requests query params. If non empty, this will be appended to the
     * requests url.
     */
    queryParams?: QueryParams;
    /**
     * Optionally pass a validator. If it returns false an `ApiError` will be thrown.
     */
    throwIf?: ResponseRejector;
    /**
     * Optionally pass a parser, defaults to the `defaultResponseParser`. Use this in case you need special handling for a request.
     */
    parser?: ResponseParser;
}) => Promise<any>;
export declare type ResponseRejector = (reqRes: RequestResponse) => boolean;
export declare type ResponseParser = (reqRes: RequestResponse) => any;
/**
 * A network error handler
 *
 * From the MDN docs:
 * > A fetch() promise will reject with a TypeError when a network error is encountered or CORS is misconfigured on
 * > the server side, although this usually means permission issues or similar â€” a 404 does not constitute
 * > a network error, for example.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
 */
export declare const withDefaultNetworkErrorHandler: (request: FetchRequest) => (error: any) => never;
export declare const withResponseLogger: (debug?: boolean | undefined) => (res: any) => any;
export declare const composeQueryString: (queryParams?: QueryParams) => string;
export declare const composeErrorHandler: (req: FetchRequest, throwByDefaultIf: ResponseRejector, throwIf?: ResponseRejector | undefined) => (res: FetchResponse) => FetchResponse;
export declare const composeRequestParser: (req: FetchRequest, defaultResponseParser: ResponseParser, responseParser?: ResponseParser | undefined) => (res: FetchResponse) => any;
/**
 * Joins two or more paths with a "/", useful for avoiding "/foo//bar/" kind of errors when you don't know if the input will already contain a slash.
 */
export declare const joinPaths: (left: string, right: string, ...paths: string[]) => string;
export declare class ApiError extends Error {
    readonly request: FetchRequest;
    readonly status: number;
    constructor(request: FetchRequest, response: FetchResponse);
}
export declare class NetworkError extends Error {
    readonly request: FetchRequest;
    constructor(message: string, request: FetchRequest);
}
export declare const isApiError: (object: any) => object is ApiError;
export declare const isNetworkError: (object: any) => object is NetworkError;
/**
 * Creates a new HttpClient.
 *
 * @param opts a configuration options object.
 */
export declare const createClient: (opts: ClientOptions) => HttpClient;
export {};
