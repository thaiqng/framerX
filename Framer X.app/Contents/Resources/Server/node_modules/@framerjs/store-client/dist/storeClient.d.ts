import { FetchFunction } from "./http";
import { Package, PublishStatus, Preflight, PackagesMetaResponse, PackageMeta } from "./types";
interface PreflightBody {
    package?: string;
    displayName?: string;
    publishing?: boolean;
}
/**
 * An HTTP based Store Client
 */
export declare class HttpStoreClient implements StoreClient {
    private readonly rootUrl;
    private readonly request;
    private readonly privateStore;
    constructor(opts: {
        privateStore: boolean;
        rootUrl: string;
        token?: string;
        fetch: FetchFunction;
        debug?: boolean;
    });
    /**
     * Finds the package with the given name.
     *
     * @param packageName a package's `name`
     */
    findByName({ packageName }: {
        packageName: string;
    }): Promise<Package>;
    /**
     * @returns true if there is a package with the given name.
     */
    containsPackage(opts: {
        friendlyName: string;
    }): Promise<{
        contained: boolean;
    }>;
    /**
     * Toggles a packages "favorite" status.
     *
     * NOTE: Unfortunately if a package is already a favorite and you try to favorite, it will result in an error.
     * We circunvent this behaviour by always calling `findByName` , disregarding the result of the toggle
     * favorite endpoint.
     *
     * @param packageName a package `name`
     * @param favorite if true will set the package as favorite, if false will unfavourite the package.
     */
    toggleFavorite(opts: {
        packageName: string;
        favorite: boolean;
    }): Promise<Package>;
    find(): Promise<Packages>;
    fetchRecents(opts: {
        offset: number;
    }): Promise<Packages>;
    fetchPackagesBySection(opts: {
        section: string;
        offset: number;
    }): Promise<Packages>;
    fetchPackagesByPublisher(opts: {
        publisherId: string;
        offset: number;
    }): Promise<Packages>;
    fetchPackagesByPopularity(opts: {
        days: number;
        offset: number;
    }): Promise<Packages>;
    fetchFeaturedPackages(opts: {
        offset: number;
    }): Promise<Packages>;
    search(opts: {
        offset: number;
        query: string;
    }): Promise<Packages>;
    getPublishStatus(opts: {
        packageName: string;
        version: string;
        isPrivate: boolean;
    }): Promise<PublishStatus>;
    fetchPreflight(body: PreflightBody): Promise<Preflight>;
    removePackage(opts: {
        packageName: string;
    }): Promise<void>;
    private fetchManyPackageMeta;
    fetchMeta({ name, dependencies }: {
        name?: string;
        dependencies?: string[];
    }): Promise<{
        meta?: PackageMeta;
        dependenciesMeta: PackagesMetaResponse;
    }>;
}
declare type Packages = {
    packages: ReadonlyArray<Package>;
    totalCount: number;
};
/**
 * A client to the store API.
 */
export interface StoreClient {
    /**
     * Finds the package with the given name.
     *
     * @param packageName a package's `name`
     */
    findByName(opts: {
        packageName: string;
    }): Promise<Package>;
    /**
     * @returns true if there is a package with the given name.
     */
    containsPackage(opts: {
        friendlyName: string;
    }): Promise<{
        contained: boolean;
    }>;
    /**
     * Toggles a package's "favorite" status.
     *
     * NOTE: Unfortunately if a package is already a favorite and you try to favorite, it will result in an error.
     * We circunvent this behaviour by always calling `findByName` , disregarding the result of the toggle
     * favorite endpoint.
     *
     * @param packageName a package `name`
     * @param favorite if true will set the package as favorite, if false will unfavourite the package.
     */
    toggleFavorite(opts: {
        packageName: string;
        favorite: boolean;
    }): Promise<Package>;
    /**
     * Fetches the recent packages.
     */
    fetchRecents(opts: {
        offset: number;
    }): Promise<Packages>;
    /**
     * Fetches the packages on the given section
     *
     * @param opts.section E.g. favorites
     */
    fetchPackagesBySection(opts: {
        offset: number;
        section: string;
    }): Promise<Packages>;
    /**
     * Fetches the packages by the given publisher.
     *
     * @param opts.publisherId a publisher's UUID
     */
    fetchPackagesByPublisher(opts: {
        offset: number;
        publisherId: string;
    }): Promise<Packages>;
    /**
     * Fetches the packages by popularity (e.g. fetches the most popular packages)
     */
    fetchPackagesByPopularity(opts: {
        offset: number;
        days: number;
    }): Promise<Packages>;
    /**
     * Fetches the featured packages.
     */
    fetchFeaturedPackages(opts: {
        offset: number;
    }): Promise<Packages>;
    /**
     * Searches for packages that match the given search query
     */
    search(opts: {
        offset: number;
        query: string;
    }): Promise<Packages>;
    /**
     * Gets the publish status of the package with the given name.
     *
     * If either the package or the version don't exist, a 404 not found error will be thrown.
     *
     * @param packageName the name of the package
     * @param version the package's version e.g. `1.0.0`
     * @param isPrivate if true looks for the package in the private store, false otheriwse.
     */
    getPublishStatus(opts: {
        packageName: string;
        version: string;
        isPrivate: boolean;
    }): Promise<PublishStatus>;
    /**
     * Note: Preflight requires either a display name or a package name.
     */
    fetchPreflight(body: PreflightBody): Promise<Preflight>;
    /**
     * NOTE: only available on the private store.
     */
    removePackage(opts: {
        packageName: string;
    }): Promise<void>;
    /**
     * Fetches all metadata related to the given package and its dependencies.
     *
     * @returns a promise that resolves to a map from package identifier to Package Meta.
     */
    fetchMeta(opts: {
        name?: string;
        dependencies?: ReadonlyArray<string>;
    }): Promise<{
        meta?: PackageMeta;
        dependenciesMeta: any;
    }>;
}
export {};
